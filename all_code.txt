#pragma once

#include "screen.hpp"

namespace CORE {

    class Renderer {
    public:
        Renderer(Screen& screen_ref);  
        void render();

    private:
        Screen& screen; 
    };

} // namespace CORE
#include "core.hpp"
#include <algorithm>
#include <cmath>
#include <thread>
#include <iostream>

namespace CORE {

// Global entity manager
ENTITY::EntityManager g_entity_manager{};

// Barycentric coordinate calculation
BarycentricCoords calculate_barycentric(const Vec2Int& p, 
                                        const Vec2Int& a, 
                                        const Vec2Int& b, 
                                        const Vec2Int& c) noexcept {
    const Vec2Int v0 = {c.x - a.x, c.y - a.y};
    const Vec2Int v1 = {b.x - a.x, b.y - a.y};
    const Vec2Int v2 = {p.x - a.x, p.y - a.y};

    const int dot00 = v0.x * v0.x + v0.y * v0.y;
    const int dot01 = v0.x * v1.x + v0.y * v1.y;
    const int dot02 = v0.x * v2.x + v0.y * v2.y;
    const int dot11 = v1.x * v1.x + v1.y * v1.y;
    const int dot12 = v1.x * v2.x + v1.y * v2.y;

    const float denom = static_cast<float>(dot00 * dot11 - dot01 * dot01);
    if (std::abs(denom) < 1e-10f) {
        return {0.0f, 0.0f, 0.0f}; // Degenerate triangle
    }

    const float inv_denom = 1.0f / denom;
    const float u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
    const float v = (dot00 * dot12 - dot01 * dot02) * inv_denom;
    const float w = 1.0f - u - v;

    return {u, v, w};
}

// Distance-based shading
char get_distance_shade(float distance, float max_distance) noexcept {
    if (distance > max_distance) return ' ';
    
    const float normalized = std::clamp(distance / max_distance, 0.0f, 1.0f);
    
    // Optimized character array - fewer lookups
    constexpr char shade_chars[] = {'@', '#', '8', '&', 'o', ':', '*', '.', '~', '-', '^', '\'', ' '};
    constexpr int num_chars = sizeof(shade_chars) - 1;
    
    const int index = static_cast<int>(normalized * (num_chars - 1));
    return shade_chars[std::clamp(index, 0, num_chars - 1)];
}

char get_enhanced_distance_shade(float distance, float max_distance) noexcept {
    if (distance > max_distance) return ' ';
    
    const float normalized = std::clamp(distance / max_distance, 0.0f, 1.0f);
    
    // Extended character set for smoother gradients
    constexpr char shade_chars[] = {
        '@', '#', '8', '&', '%', 'B', 'M', 'N', 'W', 'Q', 'R', 'O', 'o', 'a', 'h',
        'k', 'b', 'd', 'p', 'q', 'w', 'm', 'Z', 'X', 'Y', 'U', 'J', 'C', 'L',
        'z', 'c', 'v', 'u', 'n', 'x', 'r', 'j', 'f', 't', '/', '\\', '|', '(',
        '1', '{', '}', '[', ']', '?', '-', '_', '+', '~', '<', '>', 'i', '!', 'l',
        'I', ';', ':', ',', '"', '^', '`', '\'', '.', ' '
    };
    constexpr int num_chars = sizeof(shade_chars) - 1;
    
    const int index = static_cast<int>(normalized * (num_chars - 1));
    return shade_chars[std::clamp(index, 0, num_chars - 1)];
}

// Utility function for dot product
constexpr float dot_product(const Vec3Float& a, const Vec3Float& b) noexcept {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

// Camera space transformation
Vec3Float world_to_camera_space(const Vec3Float& world_pos, 
                                const FirstPersonCamera& camera) noexcept {
    // Precompute trigonometric values
    const float cos_pitch = std::cos(camera.pitch);
    const float sin_pitch = std::sin(camera.pitch);
    const float cos_yaw = std::cos(camera.yaw);
    const float sin_yaw = std::sin(camera.yaw);

    // Camera basis vectors
    const Vec3Float forward = {
        cos_pitch * sin_yaw,
        sin_pitch,
        cos_pitch * cos_yaw
    };

    const Vec3Float world_up = {0.0f, 1.0f, 0.0f};
    const Vec3Float right = world_up.cross(forward).normalize();
    const Vec3Float up = forward.cross(right);

    // Transform to camera space
    const Vec3Float relative = world_pos - camera.position;
    
    return {
        dot_product(relative, right),
        dot_product(relative, up),
        dot_product(relative, forward)
    };
}

// Screen projection
Vec2Int project_to_screen(const Vec3Float& camera_pos, 
                          float focal_length,
                          const Vec2Float& screen_size) noexcept {
    if (camera_pos.z >= -Config::NEAR_PLANE) {
        return {-1, -1}; // Behind camera
    }

    const auto projected = camera_pos.project(focal_length);
    const float x = projected.x * Config::BASE_SCALE + screen_size.x * 0.5f;
    const float y = projected.y * (Config::BASE_SCALE / Config::ASPECT_RATIO) + screen_size.y * 0.5f;

    return {
        static_cast<int>(std::clamp(x, 0.0f, screen_size.x - 1.0f)),
        static_cast<int>(std::clamp(y, 0.0f, screen_size.y - 1.0f))
    };
}

Vec4Int calculate_bounding_box(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2, Screen& screen) noexcept {
    const auto screen_size = screen.get_size();
    const int min_x = std::max(0, std::min({p0.x, p1.x, p2.x}));
    const int max_x = std::min(static_cast<int>(screen_size.x) - 1, std::max({p0.x, p1.x, p2.x}));
    const int min_y = std::max(0, std::min({p0.y, p1.y, p2.y}));
    const int max_y = std::min(static_cast<int>(screen_size.y) - 1, std::max({p0.y, p1.y, p2.y}));

    return {min_x, min_y, max_x, max_y};
}

void rasterize_textured_triangle(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2,
                                        float z0, float z1, float z2,
                                        const ENTITY::TexturedMeshEntity* textured_entity,
                                        Screen& screen,
                                        ZBuffer& z_buffer) {
    const auto [min_x, min_y, max_x, max_y] = calculate_bounding_box(p0, p1, p2, screen);

    // Precompute triangle area for barycentric calculation optimization
    const float triangle_area = static_cast<float>(
        (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y)
    );
    
    if (std::abs(triangle_area) < 1e-6f) {
        return; // Degenerate triangle
    }

    const float inv_area = 1.0f / triangle_area;

    // Rasterize pixels within bounding box
    for (int y = min_y; y <= max_y; ++y) {
        for (int x = min_x; x <= max_x; ++x) {
            const Vec2Int pixel = {x, y};
            
            // Calculate barycentric coordinates
            const BarycentricCoords bary = calculate_barycentric(pixel, p0, p1, p2);
            
            if (!bary.is_inside()) {
                continue;
            }

            // Interpolate depth using barycentric coordinates
            const float depth = bary.u * z0 + bary.v * z1 + bary.w * z2;
            
            // Early depth test
            if (depth > Config::MAX_VIEW_DISTANCE || depth < Config::NEAR_PLANE) {
                continue;
            }

            // Z-buffer test and update
            if (z_buffer.test_and_set(static_cast<size_t>(x), static_cast<size_t>(y), depth)) {
                // UV mapping using barycentric coordinates
                // Note: You might need to adjust this based on your UV coordinate system
                const float u = bary.v; // These mappings might need adjustment
                const float v = bary.w; // based on your specific UV layout

                const char tex_char = textured_entity->get_texture_char(u, v);
                
                // Only render non-transparent pixels
                if (tex_char != ' ' && tex_char != '\0') {
                    screen.set_pixel({static_cast<size_t>(x), static_cast<size_t>(y)}, tex_char);
                }
            }
        }
    }
}

// 3. Enhanced shaded triangle rasterization for consistency
void rasterize_shaded_triangle(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2,
                                      float z0, float z1, float z2,
                                      Screen& screen,
                                      ZBuffer& z_buffer) {
    const auto [min_x, min_y, max_x, max_y] = calculate_bounding_box(p0, p1, p2, screen);

    for (int y = min_y; y <= max_y; ++y) {
        for (int x = min_x; x <= max_x; ++x) {
            const Vec2Int pixel = {x, y};
            const BarycentricCoords bary = calculate_barycentric(pixel, p0, p1, p2);
            
            if (!bary.is_inside()) {
                continue;
            }

            const float depth = bary.u * z0 + bary.v * z1 + bary.w * z2;
            
            if (depth > Config::MAX_VIEW_DISTANCE || depth < Config::NEAR_PLANE) {
                continue;
            }

            if (z_buffer.test_and_set(static_cast<size_t>(x), static_cast<size_t>(y), depth)) {
                const char shade_char = get_distance_shade(depth);
                if (shade_char != ' ') {
                    screen.set_pixel({static_cast<size_t>(x), static_cast<size_t>(y)}, shade_char);
                }
            }
        }
    }
}

// Core class implementation
Core::Core(pair_uint screen_size) 
    : _screen(screen_size, DEFAULT_SETTINGS), _renderer(_screen) {
}

void Core::initialize() {
    if (on_start) {
        on_start();
    }
}

bool Core::should_cull_entity(const std::shared_ptr<ENTITY::MeshEntity>& entity, 
                              const FirstPersonCamera& camera) const noexcept {
    const auto position = entity->get_position();
    const auto scale = entity->get_scale();
    
    const Vec3Float entity_to_camera = position - camera.position;
    const float entity_distance = entity_to_camera.magnitude();
    
    // Frustum culling based on distance
    const float max_scale = std::max({scale.x, scale.y, scale.z});
    return entity_distance > Config::MAX_VIEW_DISTANCE + max_scale;
}

void Core::update_game_logic(FirstPersonCamera& camera) {
    const auto screen_size_uint = _screen.get_size();
    const Vec2Float screen_size = {
        static_cast<float>(screen_size_uint.x), 
        static_cast<float>(screen_size_uint.y)
    };

    // Clear screen buffer
    for (size_t y = 0; y < screen_size_uint.y; ++y) {
        for (size_t x = 0; x < screen_size_uint.x; ++x) {
            _screen.set_pixel({x, y}, ' ');
        }
    }

    // Initialize Z-buffer with improved class
    ZBuffer z_buffer(screen_size_uint.x, screen_size_uint.y);

    // Collect and sort entities by distance for better rendering order
    struct EntityWithDistance {
        std::shared_ptr<ENTITY::MeshEntity> entity;
        float distance;
    };

    std::vector<EntityWithDistance> sorted_entities;
    
    for (const auto& entity : g_entity_manager.get_entities()) {
        auto mesh_entity = std::dynamic_pointer_cast<ENTITY::MeshEntity>(entity);
        if (!mesh_entity || should_cull_entity(mesh_entity, camera)) {
            continue;
        }

        const Vec3Float entity_to_camera = mesh_entity->get_position() - camera.position;
        const float distance = entity_to_camera.magnitude();
        
        sorted_entities.push_back({mesh_entity, distance});
    }

    // Sort entities back-to-front for better transparency handling
    std::sort(sorted_entities.begin(), sorted_entities.end(),
              [](const EntityWithDistance& a, const EntityWithDistance& b) {
                  return a.distance > b.distance;
              });

    // Render all entities
    for (const auto& entity_data : sorted_entities) {
        const auto& mesh_entity = entity_data.entity;

        // Transform and project vertices
        std::vector<Vec2Int> projected_vertices;
        std::vector<Vec3Float> camera_vertices;
        std::vector<float> depths;

        const auto* mesh     = mesh_entity->get_mesh();
        const auto  position = mesh_entity->get_position();
        const auto  scale    = mesh_entity->get_scale();

        for (const auto& vertex : mesh->getVertices()) {
            const Vec3Float world_pos  = vertex.scale(scale) + position;
            const Vec3Float cam_vertex = world_to_camera_space(world_pos, camera);
            
            camera_vertices.push_back(cam_vertex);
            depths.push_back(cam_vertex.magnitude());
            
            const Vec2Int projected = project_to_screen(cam_vertex, camera.focal_length, screen_size);
            projected_vertices.push_back(projected);
        }

        const auto textured_entity = std::dynamic_pointer_cast<ENTITY::TexturedMeshEntity>(mesh_entity);
        
        // Render faces
        for (const auto& face : mesh->getFaces()) {
            // Skip if any vertex is behind camera
            if (projected_vertices[face.x].x < 0 || 
                projected_vertices[face.y].x < 0 || 
                projected_vertices[face.z].x < 0) {
                continue;
            }

            const auto& p0 = projected_vertices[face.x];
            const auto& p1 = projected_vertices[face.y];
            const auto& p2 = projected_vertices[face.z];

            const float z0 = depths[face.x];
            const float z1 = depths[face.y];
            const float z2 = depths[face.z];

            // Distance culling
            const float avg_depth = (z0 + z1 + z2) / 3.0f;
            if (avg_depth > Config::MAX_VIEW_DISTANCE) {
                continue;
            }

            // Backface culling
            const Vec3Float& v0_cam = camera_vertices[face.x];
            const Vec3Float& v1_cam = camera_vertices[face.y];
            const Vec3Float& v2_cam = camera_vertices[face.z];
            
            const Vec3Float edge1 = v1_cam - v0_cam;
            const Vec3Float edge2 = v2_cam - v0_cam;
            const Vec3Float normal = edge1.cross(edge2);
            
            const Vec3Float face_center = (v0_cam + v1_cam + v2_cam) * (1.0f/3.0f);
            const Vec3Float view_dir = -face_center.normalize();
            
            if (dot_product(normal, view_dir) <= 0) {
                continue; // Skip backfacing triangles
            }

            // Render triangle with improved z-buffering
            if (textured_entity) {
                rasterize_textured_triangle(p0, p1, p2, z0, z1, z2, 
                                                   textured_entity.get(), _screen, z_buffer);
            } else {
                rasterize_shaded_triangle(p0, p1, p2, z0, z1, z2, 
                                                 _screen, z_buffer);
            }
        }
    }
}

void Core::process_input(FirstPersonCamera& camera) {
    if (!is_any_key_pressed()) {
        return;
    }

    if (is_key_pressed(KeyCode::KEY_ESCAPE)) {
        _is_running = false;
        return;
    }
    
    const char input = get_pressed_key();
    const auto& input_chars = camera.input_char;
    const auto it = std::find(input_chars.begin(), input_chars.end(), input);
    if (it != input_chars.end()) {
        const int direction_index = std::distance(input_chars.begin(), it);
        camera.handle_movement(static_cast<Direction>(direction_index));
    }
}

void Core::run_game_loop() {
    FirstPersonCamera camera;

    #if !defined(_WIN32)
        enable_raw_mode();
    #endif
    
    const auto frame_duration = std::chrono::milliseconds(1000 / _target_frame_rate);
    
    while (_is_running) {
        const auto frame_start = std::chrono::steady_clock::now();
        
        // Update game logic
        if (on_update) {
            on_update();
        }
        
        update_game_logic(camera);
        process_input(camera);
        
        // Render
        _screen.clear_screen();
        _renderer.render();
        
        // Late update
        if (on_late_update) {
            on_late_update();
        }
        
        // Frame rate limiting
        const auto frame_end = std::chrono::steady_clock::now();
        const auto elapsed = frame_end - frame_start;
        if (elapsed < frame_duration) {
            std::this_thread::sleep_for(frame_duration - elapsed);
        }
    }
    
    #if !defined(_WIN32)
        disable_raw_mode();
    #endif
}

} // namespace CORE#include "camera.hpp"

namespace CORE {
    void OrbitCamera::handle_movement(Direction direction) {
        switch (direction) {
            case LEFT:  yaw   -= rot_angle_delta; break;
            case RIGHT: yaw   += rot_angle_delta; break;
            case UP:    pitch += rot_angle_delta; break;
            case DOWN:  pitch -= rot_angle_delta; break;
            case IN:    dist -= 1.0f; break;
            case OUT:   dist += 1.0f; break;
            default: break;
        }
        // Clamp pitch so the camera doesn’t flip over top/bottom
        if (pitch >  1.5f) pitch =  1.5f;  // ~≈ 85°
        if (pitch < -1.5f) pitch = -1.5f;  // ~≈ -85°
        
    }

    void FirstPersonCamera::handle_movement(Direction direction) {
        const float move_speed = 0.5f;  // how far to move per step
        const float rot_speed = 0.1f;   // how much to rotate per step (radians)

        switch (direction) {
            case LEFT:
                yaw -= rot_speed;  // rotate left
                break;
            case RIGHT:
                yaw += rot_speed;  // rotate right
                break;
            case UP: {
                // Move forward in the direction camera is facing on XZ plane
                position.x -= move_speed * sin(yaw);
                position.z -= move_speed * cos(yaw);
                break;
            }
            case DOWN: {
                // Move backward
                position.x += move_speed * sin(yaw);
                position.z += move_speed * cos(yaw);
                break;
            }
            default:
                break;
        }
    }


}#pragma once

#if defined(_WIN32)
#include <windows.h>
#include <conio.h>
#else
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/select.h>
#include "poll.h"
#endif

#include <iostream>
#include <thread>
#include <chrono>

namespace CORE {
    enum KeyCode : char {
        KEY_A = 'A',
        KEY_B = 'B',
        KEY_C = 'C',
        KEY_D = 'D',
        KEY_E = 'E',
        KEY_F = 'F',
        KEY_G = 'G',
        KEY_H = 'H',
        KEY_I = 'I',
        KEY_J = 'J',
        KEY_K = 'K',
        KEY_L = 'L',
        KEY_M = 'M',
        KEY_N = 'N',
        KEY_O = 'O',
        KEY_P = 'P',
        KEY_Q = 'Q',
        KEY_R = 'R',
        KEY_S = 'S',
        KEY_T = 'T',
        KEY_U = 'U',
        KEY_V = 'V',
        KEY_W = 'W',
        KEY_X = 'X',
        KEY_Y = 'Y',
        KEY_Z = 'Z',
        KEY_0 = '0',
        KEY_1 = '1',
        KEY_2 = '2',
        KEY_3 = '3',
        KEY_4 = '4',
        KEY_5 = '5',
        KEY_6 = '6',
        KEY_7 = '7',
        KEY_8 = '8',
        KEY_9 = '9',
        KEY_SPACE = ' ',
        KEY_ENTER = '\r',
        KEY_ESCAPE = 27, // ASCII for ESC key
    };

    // Function declarations only
    #if !defined(_WIN32)
    void enable_raw_mode();
    void disable_raw_mode();
    #endif
    
    bool is_key_pressed(KeyCode key);
    bool is_any_key_pressed();
    char get_pressed_key();
}#include "screen.hpp"

namespace CORE {

    ScreenSettings DEFAULT_SETTINGS {60};

    // Screen constructor doing initial config 
    Screen::Screen(pair_uint size, ScreenSettings set) {
        this->screen_size = size;
        this->settings = set;

        this->screen_buffer = std::vector<std::vector<char>>(
            this->screen_size.y,
            std::vector<char>(this->screen_size.x, ' ') 
        );
    }

    // Paint an individual pixel if valid position
    bool Screen::set_pixel(pair_uint pos, char rune) {
        if (pos.x >= this->screen_size.x || pos.y >= this->screen_size.y) {
            std::cerr << "invalid position coordinates entered | x : " << pos.x << " | y : " << pos.y << std::endl;
            return false;
        }
        this->screen_buffer[pos.y][pos.x] = rune;
        change = 1;
        return true; 
    }

    // Clear screen, + additional config for windows systems
    void Screen::clear_screen() {
        #if defined(_WIN32)
            HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
            COORD topLeft = {0, 0};
            SetConsoleCursorPosition(hOut, topLeft);
        #else
            std::cout << "\033[2J\033[H";
        #endif
    }


}#include "input_handling.hpp"

#ifdef _WIN32
#include <windows.h>
#include <cctype>  // for tolower
#else
#include <termios.h>
#include <unistd.h>
#include <sys/select.h>
#include <cstdio>
#endif

namespace CORE {

#ifdef _WIN32

char currently_pressed_key = 0;

bool is_any_key_pressed() {
    char ch = 0;
    for (unsigned char i = 32; i <= 127; i++) {
        if (GetAsyncKeyState(i) & 0x8000) {
            ch = tolower(i);
            break;
        }
    }
    
    if (ch != 0) {
        currently_pressed_key = ch; // Store the pressed key
        return 1;
    }

    return 0;
}

bool is_key_pressed(KeyCode key) {
    return (GetAsyncKeyState(key) & 0x8000) != 0;
}

char get_pressed_key() {
    char ch = currently_pressed_key;
    currently_pressed_key = 0; // Reset after reading
    return ch;
}

#else // Linux / macOS

static struct termios original_termios;
static bool raw_mode_enabled = false;

static char input_buffered_char = 0;
static bool input_char_ready = false;

void enable_raw_mode() {
    if (raw_mode_enabled) return;

    tcgetattr(STDIN_FILENO, &original_termios);

    termios raw = original_termios;
    raw.c_lflag &= ~(ICANON | ECHO);
    raw.c_cc[VMIN] = 0;
    raw.c_cc[VTIME] = 0;

    tcsetattr(STDIN_FILENO, TCSANOW, &raw);
    raw_mode_enabled = true;
}

void disable_raw_mode() {
    if (!raw_mode_enabled) return;

    tcsetattr(STDIN_FILENO, TCSANOW, &original_termios);
    raw_mode_enabled = false;
}

// This just checks if there's *any* input, but doesn't consume it
bool is_any_key_pressed() {
    timeval tv = {0L, 0L};
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    return select(STDIN_FILENO + 1, &fds, nullptr, nullptr, &tv) > 0;
}

// Reads and caches one character into the buffer
void poll_input() {
    if (input_char_ready) return;

    char ch;
    ssize_t n = read(STDIN_FILENO, &ch, 1);
    if (n == 1) {
        input_buffered_char = ch;
        input_char_ready = true;
    }
}

char get_pressed_key() {
    if (input_char_ready) {
        input_char_ready = false;
        return input_buffered_char;
    }

    char ch;
    ssize_t n = read(STDIN_FILENO, &ch, 1);
    return (n == 1) ? ch : 0;
}

bool is_key_pressed(KeyCode key) {
    poll_input(); // Ensure buffer is populated
    if (!input_char_ready) return false;

    return tolower(input_buffered_char) == tolower(key);
}

#endif // Platform

} // namespace CORE
#pragma once

#include "../math/math.hpp"

#include <iostream>
#include <vector>

#if defined(_WIN32)
#include <windows.h>
#endif

typedef MATH::Vec2<size_t> pair_uint;

namespace CORE {

    // ScreenSettings in the future will hold
    // all relevant screen config settings
    struct ScreenSettings {
        size_t frameRate;
    };

    extern ScreenSettings DEFAULT_SETTINGS;


    // Screen defines all functionality pertaining
    // to the literal screen shown in every frame
    // and the ability to paint the screen with pixels
    class Screen {
    public:
        Screen(pair_uint screen_size = {80, 45}, ScreenSettings settings = DEFAULT_SETTINGS);
        ~Screen() = default;

        void clear_screen();
        bool set_pixel(pair_uint position, char rune);

        const std::vector<std::vector<char>>& get_screen_buffer() const {
            return this->screen_buffer;
        }

        bool get_change() const {
            return change;
        }

        const pair_uint get_size() {
            return this->screen_size;
        } 

        void set_change(bool c) {
            change = c;
        }
    private:
        pair_uint      screen_size     {};
        ScreenSettings settings        {};

        std::vector<std::vector<char>> screen_buffer {};

        bool change {};
    };


} // CORE#pragma once
#include "screen.hpp"
#include "renderer.hpp"
#include "camera.hpp"
#include "../meshes/meshes.hpp"
#include "input_handling.hpp"
#include "../entity/entity.hpp"
#include "../entity/entity_manager.hpp"
#include <functional>
#include <vector>
#include <memory>
#include <chrono>

namespace CORE {

using Vec2Int = MATH::Vec2<int>;
using Vec2Float = MATH::Vec2<float>;
using Vec3Float = MATH::Vec3<float>;
using Vec4Int = MATH::Vec4<int>;

// Configuration constants
namespace Config {
    constexpr float ASPECT_RATIO = 1.8f;
    constexpr float BASE_SCALE = 15.0f;
    constexpr float NEAR_PLANE = 0.1f;
    constexpr float FAR_PLANE = 100.0f;
    constexpr float MAX_VIEW_DISTANCE = 15.0f;
    constexpr size_t DEFAULT_FRAME_RATE = 60;
}

// Forward declarations
class Screen;
class FirstPersonCamera;

// Barycentric coordinate calculation for triangle rasterization
struct BarycentricCoords {
    float u, v, w;
    
    constexpr bool is_inside() const noexcept {
        return u >= -1e-6f && v >= -1e-6f && w >= -1e-6f; // Small epsilon for floating point precision
    }
};

// Calculate barycentric coordinates for point p in triangle (a, b, c)
BarycentricCoords calculate_barycentric(const Vec2Int& p, 
                                        const Vec2Int& a, 
                                        const Vec2Int& b, 
                                        const Vec2Int& c) noexcept;

// Distance-based shading functions
char get_distance_shade(float distance, float max_distance = Config::MAX_VIEW_DISTANCE) noexcept;
char get_enhanced_distance_shade(float distance, float max_distance = Config::MAX_VIEW_DISTANCE) noexcept;

Vec4Int calculate_bounding_box(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2, Screen& screen) noexcept;

// Triangle rasterization functions
void rasterize_textured_triangle(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2,
                                 float z0, float z1, float z2,
                                 const ENTITY::TexturedMeshEntity* textured_entity,
                                 Screen& screen,
                                 std::vector<std::vector<float>>& z_buffer);

void rasterize_shaded_triangle(const Vec2Int& p0, const Vec2Int& p1, const Vec2Int& p2,
                               float z0, float z1, float z2,
                               Screen& screen,
                               std::vector<std::vector<float>>& z_buffer);

// Camera space transformation
Vec3Float world_to_camera_space(const Vec3Float& world_pos, 
                                const FirstPersonCamera& camera) noexcept;

// Projection utilities
Vec2Int project_to_screen(const Vec3Float& camera_pos, 
                          float focal_length,
                          const Vec2Float& screen_size) noexcept;

// Core engine class
class Core {
public:
    explicit Core(pair_uint screen_size);
    ~Core() = default;
    
    // Non-copyable, movable
    Core(const Core&) = delete;
    Core& operator=(const Core&) = delete;
    Core(Core&&) = default;
    Core& operator=(Core&&) = default;
    
    void initialize();
    void run_game_loop();
    
    void set_target_framerate(size_t rate) noexcept { _target_frame_rate = rate; }
    
    // Game loop callbacks
    std::function<void()> on_start       = nullptr;
    std::function<void()> on_update      = nullptr;
    std::function<void()> on_late_update = nullptr;

private:
    void update_game_logic(FirstPersonCamera& camera);
    void process_input(FirstPersonCamera& camera);
    bool should_cull_entity(const std::shared_ptr<ENTITY::MeshEntity>& entity, 
                            const FirstPersonCamera& camera) const noexcept;
    
    size_t _target_frame_rate = Config::DEFAULT_FRAME_RATE;
    Screen _screen;
    Renderer _renderer;
    bool _is_running = true;
};

class ZBuffer {
private:
    std::vector<std::vector<float>> buffer;
    size_t width, height;

public:
    ZBuffer(size_t w, size_t h) : width(w), height(h) {
        buffer.resize(height, std::vector<float>(width, Config::FAR_PLANE));
    }

    void clear() {
        for (auto& row : buffer) {
            std::fill(row.begin(), row.end(), Config::FAR_PLANE);
        }
    }

    bool test_and_set(size_t x, size_t y, float depth) {
        if (x >= width || y >= height) return false;
        if (depth < buffer[y][x]) {
            buffer[y][x] = depth;
            return true;
        }
        return false;
    }

    float get_depth(size_t x, size_t y) const {
        if (x >= width || y >= height) return Config::FAR_PLANE;
        return buffer[y][x];
    }

    void resize(size_t w, size_t h) {
        width = w;
        height = h;
        buffer.resize(height, std::vector<float>(width, Config::FAR_PLANE));
    }
};


// Global entity manager (consider dependency injection in the future)
extern ENTITY::EntityManager g_entity_manager;

} // namespace CORE#include "renderer.hpp"

#include <iostream>

namespace CORE {

    Renderer::Renderer(Screen& screen_ref)
        : screen(screen_ref) {}

    void Renderer::render() {
        screen.clear_screen();

        auto buffer = screen.get_screen_buffer();
        for (const auto &row : buffer) {
            for (const auto &ch : row) {
                std::cout << ch;
            }
            std::cout << '\n';
        }
    }

} // CORE// camera.hpp
#pragma once
#include "../math/math.hpp"

#include <vector>

#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

namespace CORE {
    enum Direction { LEFT, RIGHT, UP, DOWN, IN, OUT };


    class Camera {
    public:
        Camera(bool /*dummy*/ = true) {}
        virtual ~Camera() = default;

        float focal_length = 6.0f; // focal length for projection
    };

    class OrbitCamera : public Camera {
    public:
        // Keep track of yaw (rotation around Y) and pitch (rotation around X)
        float yaw   = 0.0f; // left-right
        float pitch = 0.0f; // up-down
        float dist  = 4.0f; // camera distance from origin (you were using +4 before)

        // WASD/arrow keys drive these deltas in radians per keypress/frame
        float rot_angle_delta = 0.1f;

        // Keys: a/d → yaw, w/s → pitch
        std::vector<char> input_char {'a','d','w','s','z','x'};

        OrbitCamera(float initYaw = 0.0f, float initPitch = 0.0f, float radius = 4.0f)
            : yaw(initYaw), pitch(initPitch), dist(radius) {}

        // Adjust angles based on input
        void handle_movement(Direction direction);

        MATH::Vec3<float> world_to_view(const MATH::Vec3<float>& point) const {
            auto view = point;
            view = view.rotate_y(-yaw).rotate_x(-pitch);
            view.z += dist;
            return view;
        }
    };

    class FirstPersonCamera : public Camera {
    public:
        MATH::Vec3<float> position {0.0f, 0.0f, 0.0f}; // Default position at origin
        float yaw = 0.0f; // left-right rotation
        float pitch = 0.0f; // up-down rotation

        std::vector<char> input_char {'a','d','w','s','z','x'};

        FirstPersonCamera(float initYaw = 0.0f, float initPitch = 0.0f)
            : yaw(initYaw), pitch(initPitch) {}

        void handle_movement(Direction direction);

        MATH::Vec3<float> world_to_view(const MATH::Vec3<float>& point) const {
            auto view = point;
            view = view.rotate_y(-yaw).rotate_x(-pitch);
            return view;
        }
    };
}
#pragma once
#include "entity.hpp"
#include <vector>
#include <memory>

namespace ENTITY {
    class EntityManager {
    private:
        std::vector<std::shared_ptr<Entity>> entities;

    public:
        void add_entity(const std::shared_ptr<Entity>& entity) {
            entities.push_back(entity);
        }

        const std::vector<std::shared_ptr<Entity>>& get_entities() const {
            return entities;
        }
    };
} // namespace ENTITY
#pragma once 

#include "../math/math.hpp"
#include "../meshes/meshes.hpp"
#include "../texture/texture.hpp"

#include <iostream>
#include <memory>

namespace ENTITY {

    class Entity {
    private:
        MATH::Vec3<float> position {0.0f, 0.0f, 0.0f}; // Default position at origin
    public:
        virtual ~Entity() = default;

        // Entities can have a position in 3D space
        virtual MATH::Vec3<float> get_position() const {
            return position;
        }

        virtual void set_position(const MATH::Vec3<float>& pos) {
            position = pos;
        }
    };

    class MeshEntity : public Entity {
    private:
        MATH::Vec3<float> scale {1.0f, 1.0f, 1.0f}; // Default scale of 1 in all dimensions

        MESHES::Mesh* mesh = nullptr; // Pointer to the mesh data
    public:
        MeshEntity(MESHES::Mesh* mesh_data) : mesh(mesh_data) {
            if (!mesh) {
                throw std::invalid_argument("Mesh data cannot be null");
            }
        }
        virtual ~MeshEntity() = default;

        // Entities can have a scale
        virtual MATH::Vec3<float> get_scale() const {
            return scale;
        }

        virtual void set_scale(const MATH::Vec3<float>& new_scale) {
            scale = new_scale;
        }

        virtual MESHES::Mesh* get_mesh() const {
            return mesh;
        }
    };

    class TexturedMeshEntity : public MeshEntity {
    private:
        std::shared_ptr<TEXTURE::Texture2D> texture;
        std::vector<std::string> texture_data;
    public:
        TexturedMeshEntity(MESHES::Mesh* mesh_data, std::shared_ptr<TEXTURE::Texture2D> tex) 
            : MeshEntity(mesh_data), texture(tex) {
            if (texture) {
                texture_data = texture->generate_texture();
            }
        }
        
        virtual ~TexturedMeshEntity() = default;
        
        std::shared_ptr<TEXTURE::Texture2D> get_texture() const {
            return texture;
        }
        
        const std::vector<std::string>& get_texture_data() const {
            return texture_data;
        }
        
        // Get texture character at UV coordinates (0-1 range)
        char get_texture_char(float u, float v) const {
            if (texture_data.empty()) return '#';
            
            // Clamp UV coordinates
            u = std::max(0.0f, std::min(1.0f, u));
            v = std::max(0.0f, std::min(1.0f, v));
            
            // Convert to texture coordinates
            int tex_x = static_cast<int>(u * (texture_data[0].size() - 1));
            int tex_y = static_cast<int>(v * (texture_data.size() - 1));
            
            return texture_data[tex_y][tex_x];
        }
    };
} // namespace ENTITY#pragma once

#include <string>
#include <tuple>
#include <sstream>
#include <iomanip>

namespace COLOR {

static std::string RGB_to_HEX(int r, int g, int b) {
    std::ostringstream oss;
    oss << "#" << std::hex << std::setfill('0') << std::setw(2) << r
        << std::setw(2) << g << std::setw(2) << b;
    return oss.str();
}

static std::string RGB_to_HEX(const std::tuple<int, int, int>& rgb) {
    return RGB_to_HEX(std::get<0>(rgb), std::get<1>(rgb), std::get<2>(rgb));
}


} // namespace COLOR

#pragma once

#include <math.h>

namespace MATH {
    template<typename T>
    struct Vec2 {
        T x, y;

        T magnitude() const {
            return sqrt(x * x + y * y);
        }

        Vec2 normalize() const {
            const T m = magnitude();
            return { x / m, y / m };
        }

        inline Vec2 operator+(const Vec2& other) const {
            return {x + other.x, y + other.y};
        }

        inline T operator*(const Vec2& other) const {
            return x * other.x + y * other.y;
        }

        inline bool operator==(const Vec2& other) const {
            return (x == other.x && y == other.y);
        }
    };

    template<typename T>
    struct Vec3 {
        T x, y, z;

        T magnitude() const {
            return sqrt(x * x + y * y + z * z);
        }

        Vec3 normalize() const {
            const T m = magnitude();
            return { x / m, y / m, z / m };
        }

        Vec3 cross(const Vec3& other) const {
            return {y * other.z - z * other.y,
                    z * other.x - x * other.z,
                    x * other.y - y * other.x};
        }

        inline Vec3 operator+(const Vec3& other) const {
            return {x + other.x, y + other.y, z + other.z};
        }

        inline Vec3 operator+=(const Vec3& other) {
            x += other.x;
            y += other.y;
            z += other.z;
            return *this;
        }

        inline Vec3 operator*(const int o) const {
            return {x * o, y * o, z * o};
        }

        inline Vec3 operator-(const Vec3& other) const {
            return {x - other.x, y - other.y, z - other.z};
        }

        inline Vec3 operator-=(const Vec3& other) {
            x -= other.x;
            y -= other.y;
            z -= other.z;
            return *this;
        }

        inline T operator*(const Vec3& other) const {
            return x * other.x + y * other.y + z * other.z;
        }

        inline bool operator==(const Vec3& other) const {
            return (x == other.x && y == other.y && z == other.z);
        }

        Vec3 rotate_x(float angle_rad) {
            float cos_a = cos(angle_rad);  
            float sin_a = sin(angle_rad);
            return {
                x,                          
                y * cos_a - z * sin_a,    
                z * cos_a + y * sin_a
            };
        }

        Vec3 rotate_y(float angle_rad) {
            float cos_a = cos(angle_rad);  
            float sin_a = sin(angle_rad);
            return {
                x * cos_a + z * sin_a,
                y,
                z * cos_a - x * sin_a,
            };
        }

        Vec3 rotate_z(float angle_rad) {
            float cos_a = cos(angle_rad);  
            float sin_a = sin(angle_rad);
            return {
                x * cos_a - y * sin_a,
                x * sin_a + y * cos_a, 
                z 
            };
        }

        Vec2<T> project(float focal_length = 1.0f) const{
            if (z == 0) return {x, y}; 
            return {
                (focal_length * x) / z,
                (focal_length * y) / z
            };
        }

        Vec3<T> operator-() const {
            return {-x, -y, -z};
        }

        Vec3<T> scale(Vec3<T> scale_factor) const {
            return {x * scale_factor.x, y * scale_factor.y, z * scale_factor.z};
        }
    };

    template<typename T>
    struct Vec4 {
        T x, y, z, w;

        Vec4<T> operator+(const Vec4<T>& other) const {
            return {x + other.x, y + other.y, z + other.z, w + other.w};
        }

        Vec4<T> operator*(const T scalar) const {
            return {x * scalar, y * scalar, z * scalar, w * scalar};
        }

        Vec4<T> operator-(const Vec4<T>& other) const {
            return {x - other.x, y - other.y, z - other.z, w - other.w};
        }
    };
}

#include "meshes.hpp"

namespace MESHES {
    Cube static_cube_mesh {};
}// Enhanced meshes.hpp - Add face support
#pragma once
#include "../math/math.hpp"
#include <vector>

namespace MESHES {
    // Triangle face structure
    typedef MATH::Vec3<size_t> Face;

    class Mesh {
    public:
        Mesh() = default;
        virtual ~Mesh() = default;
        virtual const std::vector<MATH::Vec3<float>>& getVertices() const = 0;
        virtual const std::vector<MATH::Vec2<size_t>>& getEdges() const = 0;
        virtual const std::vector<Face>& getFaces() const = 0;  // New method
    };

    class Cube : public Mesh {
    private:
        std::vector<MATH::Vec3<float>> vertices = {
            {-1, -1, -1},  // 0
            { 1, -1, -1},  // 1
            { 1,  1, -1},  // 2
            {-1,  1, -1},  // 3
            {-1, -1,  1},  // 4
            { 1, -1,  1},  // 5
            { 1,  1,  1},  // 6
            {-1,  1,  1}   // 7
        };

        std::vector<MATH::Vec2<size_t>> edges = {
            {0,1}, {1,2}, {2,3}, {3,0},  // Front face
            {4,5}, {5,6}, {6,7}, {7,4},  // Back face
            {0,4}, {1,5}, {2,6}, {3,7}   // Connecting edges
        };

        // Define faces as triangles (2 triangles per cube face)
        std::vector<Face> faces = {
            // Front face (-Z)
            Face{0, 1, 2}, Face{0, 2, 3},
            // Back face (+Z)
            Face{4, 7, 6}, Face{4, 6, 5},
            // Left face (-X)
            Face{0, 3, 7}, Face{0, 7, 4},
            // Right face (+X)
            Face{1, 5, 6}, Face{1, 6, 2},
            // Bottom face (-Y)
            Face{0, 4, 5}, Face{0, 5, 1},
            // Top face (+Y)
            Face{3, 2, 6}, Face{3, 6, 7}
        };

    public:
        const std::vector<MATH::Vec3<float>>& getVertices() const override {
            return vertices;
        }

        const std::vector<MATH::Vec2<size_t>>& getEdges() const override {
            return edges;
        }

        const std::vector<Face>& getFaces() const override {
            return faces;
        }
    };

    extern Cube static_cube_mesh;
}#include "texture.hpp"

namespace TEXTURE {

    Texture::Texture(std::string texture_pattern)
        : texture_pattern(std::move(texture_pattern)) {}

    Texture2D::Texture2D(size_t width, size_t height, std::string pattern)
        : Texture(std::move(pattern)), width(width), height(height) {}

    void Texture2D::set_dimensions(size_t width, size_t height) {
        this->width = width;
        this->height = height;
    }

    std::vector<std::string> Texture2D::generate_texture() {
        std::vector<std::string> texture;
        size_t pattern_size = texture_pattern.size();
        size_t pattern_idx = 0;

        for (size_t i = 0; i < height; ++i) {
            std::string line;
            for (size_t j = 0; j < width; ++j) {
                line.push_back(texture_pattern[pattern_idx % pattern_size]);
                ++pattern_idx;
            }
            texture.push_back(std::move(line));
        }

        return texture;
    }

}
#pragma once

#include <string>
#include <vector>

namespace TEXTURE {

class Texture {
protected:
    std::string texture_pattern;

public:
    Texture(std::string texture_pattern);
    virtual std::vector<std::string> generate_texture() = 0;
    virtual ~Texture() = default;
};

class Texture2D : protected Texture {
private:
    size_t width;
    size_t height;

public:
    Texture2D(size_t width, size_t height, std::string pattern);
    void set_dimensions(size_t width, size_t height);
    std::vector<std::string> generate_texture() override;
};

}
#include "./core/core.hpp"
#include <iostream>
#include <memory>
#include <algorithm>
#include <random>

void initialize_scene() {
    auto& entity_manager = CORE::g_entity_manager;
    auto* cube_mesh = &MESHES::static_cube_mesh;
    
    // Create different texture patterns
    auto brick_texture = std::make_shared<TEXTURE::Texture2D>(8, 8, "####@@@@");
    auto wood_texture = std::make_shared<TEXTURE::Texture2D>(6, 6, "|||---");
    auto metal_texture = std::make_shared<TEXTURE::Texture2D>(4, 4, "$$$$####");
    
    auto plain_cube1 = std::make_shared<ENTITY::MeshEntity>(cube_mesh);
    plain_cube1->set_position({0.0f, 0.0f, -4.0f});
    plain_cube1->set_scale({2.0f, 2.0f, 2.0f});
    entity_manager.add_entity(plain_cube1);
    
    // auto plain_cube2 = std::make_shared<ENTITY::MeshEntity>(cube_mesh);
    // plain_cube2->set_position({-2.0f, 0.0f, -4.0f});
    // plain_cube2->set_scale({2.0f, 0.5f, 2.0f});
    // entity_manager.add_entity(plain_cube2);

    // auto plain_cube3 = std::make_shared<ENTITY::MeshEntity>(cube_mesh);
    // plain_cube1->set_position({0.0f, 0.0f, -1.0f});
    // plain_cube1->set_scale({0.5f, 0.5f, 0.5f});
    // entity_manager.add_entity(plain_cube3);
    
    // auto plain_cube4 = std::make_shared<ENTITY::MeshEntity>(cube_mesh);
    // plain_cube4->set_position({-6.0f, 0.0f, -12.0f});
    // plain_cube4->set_scale({2.0f, 0.5f, 2.0f});
    // entity_manager.add_entity(plain_cube4);

    // --- Maze generation parameters ---
    // const int maze_width = 21; // must be odd for maze generation
    // const int maze_height = 21; // must be odd for maze generation
    // const float cell_size = 1.0f;
    // std::vector<std::vector<bool>> maze(maze_height, std::vector<bool>(maze_width, true));

    // // Ensure starting cell is within bounds
    // if (maze_height > 1 && maze_width > 1) {
    //     maze[1][1] = false;
    //     std::function<void(int, int)> carve = [&](int x, int y) {
    //         std::vector<std::pair<int, int>> dirs = {{0,1},{1,0},{0,-1},{-1,0}};
    //         // Shuffle directions for randomness
    //         std::random_device rd;
    //         std::mt19937 g(rd());
    //         std::shuffle(dirs.begin(), dirs.end(), g);
    //         for (auto [dx, dy] : dirs) {
    //             int nx = x + dx * 2, ny = y + dy * 2;
    //             if (nx > 0 && ny > 0 && nx < maze_width && ny < maze_height && maze[ny][nx]) {
    //                 maze[y + dy][x + dx] = false;
    //                 maze[ny][nx] = false;
    //                 carve(nx, ny);
    //             }
    //         }
    //     };
    //     if (maze_height > 1 && maze_width > 1) {
    //         carve(1, 1);
    //     }
    // };

    // for (int y = 0; y < maze_height; ++y) {
    //     for (int x = 0; x < maze_width; ++x) {
    //         if (maze[y][x]) {
    //             auto wall = std::make_shared<ENTITY::MeshEntity>(cube_mesh);
    //             wall->set_position({(float)x * cell_size - 5.0f, 0.0f, (float)y * cell_size - 10.0f});
    //             wall->set_scale({0.5f, 0.5f, 0.5f});
    //             entity_manager.add_entity(wall);
    //         }
    //     }
    // }
    
    std::cout << "Scene initialized with " << entity_manager.get_entities().size() << " entities.\n";
}

void update_scene() {
    // Add any per-frame updates here
    // For example: rotate objects, update animations, etc.
}

void cleanup_scene() {
    std::cout << "Cleaning up scene...\n";
}

int main() {
    try {
        std::cout << "=== 3D ASCII Renderer ===\n";
        std::cout << "Controls:\n";
        std::cout << "  W/S - Move forward/backward\n";
        std::cout << "  A/D - Turn left/right\n";
        std::cout << "  Q   - Quit\n";
        std::cout << "========================\n\n";
        
        // Create core engine instance
        auto core = CORE::Core({100, 50}); // Larger screen for better visibility
        
        // Set up callbacks
        core.on_start = initialize_scene;
        core.on_update = update_scene;
        core.on_late_update = cleanup_scene;
        
        // Configure engine
        core.set_target_framerate(30); // Lower framerate for ASCII rendering
        
        // Initialize and run
        core.initialize();
        core.run_game_loop();
        
        std::cout << "\nThanks for using the 3D ASCII Renderer!\n";
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}